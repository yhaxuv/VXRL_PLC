C51 COMPILER V9.52.0.0   MAIN                                                              08/12/2018 14:29:52 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE main.c LARGE BROWSE DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          
   2          #include        "config.H"
*** WARNING C329 IN LINE 280 OF STC15Fxxxx.H: single-line comment contains line-continuation
   3          #include        "main.H"
   4          typedef unsigned char BYTE;
   5          typedef unsigned int WORD;
   6          
   7          #define CMD_IDLE    0               // 侍C
   8          #define CMD_READ    1               //IAP熳x取Y料
   9          #define CMD_PROGRAM 2               //IAP入Y料O
  10          #define CMD_ERASE   3               //IAP扒宄Y料O
  11          
  12          //#define ENABLE_IAP 0x80           //if SYSCLK<30MHz
  13          //#define ENABLE_IAP 0x81           //if SYSCLK<24MHz
  14          #define ENABLE_IAP  0x82            //if SYSCLK<20MHz
  15          //#define ENABLE_IAP 0x83           //if SYSCLK<12MHz
  16          //#define ENABLE_IAP 0x84           //if SYSCLK<6MHz
  17          //#define ENABLE_IAP 0x85           //if SYSCLK<3MHz
  18          //#define ENABLE_IAP 0x86           //if SYSCLK<2MHz
  19          //#define ENABLE_IAP 0x87           //if SYSCLK<1MHz
  20          
  21          //代刚歆}
  22          #define IAP_ADDRESS 0x04000
  23          
  24          void Delay(BYTE n);
  25          void IapIdle();
  26          BYTE IapReadByte(WORD addr);
  27          void IapProgramByte(WORD addr, BYTE dat);
  28          void IapEraseSector(WORD addr);
  29          unsigned char id_data;  
  30          
  31          void app_command(void);
  32          //-----------------------------------------------------------//
  33          void main(void)
  34          {
  35   1       
  36   1          UART_config();
  37   1          GPIO_config();
  38   1          Timer_config();
  39   1          ADC_config();
  40   1          EA = 1;
  41   1          GET_ID();
  42   1        SBUF=ID; 
  43   1          ch=2;
  44   1        
  45   1          Delay(10);   //y入ID
  46   1        id_data=IapReadByte(0x4000); 
  47   1        ID=id_data;
  48   1        
  49   1          while (1)
  50   1          {
  51   2              if(temp1>200){
  52   3                  temp1=0;
  53   3                  temp2++;
  54   3            temp3++;
C51 COMPILER V9.52.0.0   MAIN                                                              08/12/2018 14:29:52 PAGE 2   

  55   3                  if(temp2>100){
  56   4                    temp2=0;
  57   4                  }
  58   3              }
  59   2          if(temp3<10){
  60   3            P32=0;
  61   3            add1=0;
  62   3          }
  63   2          else if(temp3<800){
  64   3            P32=1;
  65   3          }
  66   2          else if(temp3<810){
  67   3            if(temp3==800){
  68   4              Cal_DHT11();
  69   4              temp3++;
  70   4            }     
  71   3          }
  72   2          else{     
  73   3            temp3=0;    
  74   3          }
  75   2              if(rx1_to>=400){
  76   3                rx1_to=0;
  77   3                if(rx1_cnt>0){
  78   4                  modbus_s();
  79   4                  rx1_cnt=0;
  80   4                }
  81   3                GET_ADC();
  82   3            if(count2>=500){
  83   4            count2=0;  
  84   4              Cal_adc();
  85   4            }
  86   3              }
  87   2          if(rx2_to>=400){
  88   3                rx2_to=0;
  89   3                if(rx2_cnt>0){
  90   4            app_command();
  91   4                  rx2_cnt=0;      
  92   4                }
  93   3          }  
  94   2              output();
  95   2      
  96   2          }
  97   1      }
  98          //-----------------------------------------------------------//
  99          
 100          void app_command(void){
 101   1      unsigned char buf;  
 102   1         if(rx2_cnt>0){
 103   2             if(RX2_Buffer[0]==0){
 104   3             RX2_Buffer[0]=0x01;  
 105   3               if(RX2_Buffer[1]==0){
 106   4                 if(RX2_Buffer[2]==0){
 107   5      
 108   5                 if(RX2_Buffer[3]==0x30){
 109   6                id_data = RX2_Buffer[6]&0x0f;
 110   6                id_data += (RX2_Buffer[5]&0x0f)*10;
 111   6                id_data += (RX2_Buffer[4]&0x0f)*100;  
 112   6                    IapEraseSector(0x4000);    //清除Y料
 113   6                          IapProgramByte(0x4000, id_data);  
 114   6                id_data=IapReadByte(0x4000); 
 115   6                ID=id_data;
 116   6               }
C51 COMPILER V9.52.0.0   MAIN                                                              08/12/2018 14:29:52 PAGE 3   

 117   5                 else if(RX2_Buffer[3]==0x31){
 118   6                if(P34==0){          //^器1
 119   7                  Modbuf_Buffer[1]&=0xfe;
 120   7                }
 121   6                else{
 122   7                  Modbuf_Buffer[1]|=0x01;
 123   7                }
 124   6               }  
 125   5               else if(RX2_Buffer[3]==0x32){
 126   6                if(P35==0){          //^器2 
 127   7                  Modbuf_Buffer[1]&=0xfd;
 128   7                }
 129   6                else{
 130   7                  Modbuf_Buffer[1]|=0x02;
 131   7                }          
 132   6               }         
 133   5                 }         
 134   4               }         
 135   3             }     
 136   2           
 137   2                 P27=1;
 138   2                 tx2_end=17;
 139   2                 tx2_cnt=1;
 140   2               buf=TX2_Buffer[0]=0x00; //^a*3 
 141   2             TX2_Buffer[1]=0x00;
 142   2             TX2_Buffer[2]=0x00;
 143   2             TX2_Buffer[3]=0x10;  //L度
 144   2             //TX2_Buffer[4]=ID;    //站
 145   2             TX2_Buffer[4]=id_data;    //站      
 146   2             TX2_Buffer[5]=~P34;  //^器1
 147   2             TX2_Buffer[5]+=0x30;
 148   2             TX2_Buffer[6]=~P35;  //^器2
 149   2             TX2_Buffer[6]+=0x30;      
 150   2             TX2_Buffer[7]=Modbuf_Buffer[10];   //CH1流
 151   2             TX2_Buffer[8]=Modbuf_Buffer[11];   
 152   2             TX2_Buffer[9]=Modbuf_Buffer[14];   //CH2流
 153   2             TX2_Buffer[10]=Modbuf_Buffer[15];
 154   2             TX2_Buffer[11]=Modbuf_Buffer[18];  //CH1
 155   2             TX2_Buffer[12]=Modbuf_Buffer[19];
 156   2             TX2_Buffer[13]=Modbuf_Buffer[20];  //CH2涵
 157   2             TX2_Buffer[14]=Modbuf_Buffer[21];  
 158   2             TX2_Buffer[15]=0x0d; //尾a
 159   2             TX2_Buffer[16]=0x0a; 
 160   2                 S2BUF=buf;
 161   2         }
 162   1      }
 163          //-----------------------------------------------------------//
 164          void UART_config(void){
 165   1         SCON = 0x50;   //8bit and variable baudrate
 166   1         AUXR |= 0x40;    //Timer1's clock is Fosc (1T)
 167   1         AUXR &= 0xFE;    //Use Timer1 as baudrate generator
 168   1         TMOD &= 0x0F;    //Set Timer1 as 16-bit auto reload mode
 169   1         TL1 = 0xC7;    //Initial timer value
 170   1         TH1 = 0xFE;    //Initial timer value
 171   1         ET1 = 0;   //Disable Timer1 interrupt
 172   1         TR1 = 1;   //Timer1 running
 173   1           ES = 1;
 174   1      
 175   1           S2CON = 0x50;           //8bit and variable baudrate
 176   1           AUXR |= 0x04;           //Timer2's clock is Fosc (1T)
 177   1           TL2 = 0xC7;             //Initial timer value
 178   1           TH2 = 0xFE;             //Initial timer value
C51 COMPILER V9.52.0.0   MAIN                                                              08/12/2018 14:29:52 PAGE 4   

 179   1           AUXR |= 0x10;           //Timer2 running
 180   1           UART2_INT_ENABLE();
 181   1      
 182   1           P27 = 0;
 183   1           P55 = 0;
 184   1      }
 185          //-----------------------------------------------------------//
 186          void GPIO_config(void){
 187   1           P1M1 = 0x3c;
 188   1           P1M0 = 0x3c;
 189   1           P0M1 = 0x00;
 190   1           P0M0 = 0x00;
 191   1           P2M1 = 0x00;
 192   1           P2M0 = 0x00;
 193   1           P3M1 = 0x00;
 194   1           P3M0 = 0x00;
 195   1         P5M1 = 0x00;
 196   1           P5M0 = 0x00;
 197   1         Modbuf_Buffer[1]=3;
 198   1      }
 199          //-----------------------------------------------------------//
 200          void Timer_config(void){        //10us@12.000MHz
 201   1              TL0 = 0x88;   //Initial timer value
 202   1              TH0 = 0xFF;   //Initial timer value
 203   1              TF0 = 0;                //Clear TF0 flag
 204   1              TR0 = 1;                //Timer0 start run
 205   1              Timer0_1T();
 206   1              Timer0_16bitAutoReload();
 207   1              Timer0_InterruptEnable();
 208   1              Timer0_Run();
 209   1      }
 210          //-----------------------------------------------------------//
 211          void ADC_config(void){
 212   1           P1ASF = 0x3c;                   //]wP1fADf
 213   1           ADC_RES = 0;                    //M埃挡GHs竟
 214   1           ADC_CONTR = ADC_POWER | ADC_SPEEDLL | ch | ADC_START;
 215   1      }
 216          //-----------------------------------------------------------//
 217          void timer0_int (void) interrupt TIMER0_VECTOR
 218          {
 219   1              temp1++;
 220   1              if(P21==1){
 221   2                read=1;
 222   2                if(count1<10){
 223   3                  count1++;
 224   3                }
 225   2              }
 226   1              else{
 227   2                if(read==1){
 228   3                  read=0;
 229   3                  DHT11_buf[add1]=count1;
 230   3                  add1++;
 231   3                  count1=0;
 232   3                }
 233   2              }
 234   1              rx1_to++;
 235   1          rx2_to++;
 236   1      }
 237          
 238          /********************* UART1い_ㄧΑ************************/
 239          void UART1_int (void) interrupt UART1_VECTOR
 240          {
C51 COMPILER V9.52.0.0   MAIN                                                              08/12/2018 14:29:52 PAGE 5   

 241   1      //    unsigned char buf;
 242   1          if(RI)
 243   1          {
 244   2              RI = 0;
 245   2              rx1_to=0;
 246   2              if(rx1_cnt<128){
 247   3                RX1_Buffer[rx1_cnt]=SBUF;
 248   3                rx1_cnt++;
 249   3              }
 250   2          }
 251   1          if(TI)
 252   1          {
 253   2              TI = 0;
 254   2              if(tx1_cnt<tx1_end){
 255   3                SBUF=RX1_Buffer[tx1_cnt];
 256   3                tx1_cnt++;
 257   3              }
 258   2              else{
 259   3                P55=0;
 260   3              }
 261   2          }
 262   1      } 
 263          /********************* UART2い_ㄧΑ************************/
 264          void UART2_int (void) interrupt UART2_VECTOR
 265          {
 266   1          //unsigned char buf;
 267   1      
 268   1          if(RI2)
 269   1          {
 270   2              CLR_RI2();
 271   2              //buf=S2BUF;
 272   2              //P27=1;
 273   2              //S2BUF=buf;
 274   2              rx2_to=0;
 275   2              if(rx2_cnt<128){
 276   3                RX2_Buffer[rx2_cnt]=S2BUF;
 277   3                rx2_cnt++;
 278   3              }   
 279   2          }
 280   1          if(TI2)
 281   1          {
 282   2              CLR_TI2();
 283   2              //P27=0;
 284   2              if(tx2_cnt<tx2_end){
 285   3                S2BUF=TX2_Buffer[tx2_cnt];
 286   3                tx2_cnt++;
 287   3              }
 288   2              else{
 289   3                P27=0;
 290   3              }   
 291   2          }
 292   1      
 293   1      } 
 294          /**********************************************/
 295          void GET_ID(void)
 296          {
 297   1           if(P36==0){
 298   2              Modbuf_Buffer[0]|=0x01; 
 299   2           }
 300   1           else{
 301   2              Modbuf_Buffer[0]&=0xfe; 
 302   2           }
C51 COMPILER V9.52.0.0   MAIN                                                              08/12/2018 14:29:52 PAGE 6   

 303   1           if(P37==0){
 304   2              Modbuf_Buffer[0]|=0x02; 
 305   2           }
 306   1           else{
 307   2              Modbuf_Buffer[0]&=0xfd; 
 308   2           }
 309   1           if(P20==0){
 310   2              Modbuf_Buffer[0]|=0x04; 
 311   2           }
 312   1           else{
 313   2              Modbuf_Buffer[0]&=0xfb; 
 314   2           }
 315   1           if(P21==0){
 316   2              Modbuf_Buffer[0]|=0x08; 
 317   2           }
 318   1           else{
 319   2              Modbuf_Buffer[0]&=0xf7; 
 320   2           }  
 321   1           if(P22==0){
 322   2              Modbuf_Buffer[0]|=0x10; 
 323   2           }
 324   1           else{
 325   2              Modbuf_Buffer[0]&=0xef; 
 326   2           }
 327   1           if(P23==0){
 328   2              Modbuf_Buffer[0]|=0x20; 
 329   2           }
 330   1           else{
 331   2              Modbuf_Buffer[0]&=0xdf; 
 332   2           }
 333   1           if(P24==0){
 334   2              Modbuf_Buffer[0]|=0x40; 
 335   2           }
 336   1           else{
 337   2              Modbuf_Buffer[0]&=0xbf; 
 338   2           }  
 339   1           if(P25==0){
 340   2              Modbuf_Buffer[0]|=0x80; 
 341   2           }
 342   1           else{
 343   2              Modbuf_Buffer[0]&=0x7f; 
 344   2           }  
 345   1           ID=Modbuf_Buffer[0];    
 346   1      }
 347          /**********************************************/
 348          unsigned int usMBCRC16(unsigned int usLen )
 349          {
 350   1          unsigned char           ucCRCHi = 0xFF;
 351   1          unsigned char          ucCRCLo = 0xFF;
 352   1          unsigned int          iIndex;
 353   1          unsigned char j;   j=0;
 354   1          
 355   1          while( usLen-- ){
 356   2              iIndex = ucCRCLo ^ RX1_Buffer[j];
 357   2              j++;
 358   2              ucCRCLo = ( unsigned char )( ucCRCHi ^ aucCRCHi[iIndex] );
 359   2              ucCRCHi = aucCRCLo[iIndex];
 360   2          }
 361   1          return ( unsigned int )( ucCRCHi << 8 | ucCRCLo );
 362   1      }
 363          /**********************************************/ 
 364          void modbus_s(void){
C51 COMPILER V9.52.0.0   MAIN                                                              08/12/2018 14:29:52 PAGE 7   

 365   1       unsigned int crc,crc_buf,addr,len,i;   
 366   1           if(RX1_Buffer[0]==ID){
 367   2             crc_buf=usMBCRC16((rx1_cnt-2));
 368   2             crc=(RX1_Buffer[rx1_cnt-1]*256)+RX1_Buffer[rx1_cnt-2];
 369   2             if(crc==crc_buf){
 370   3               addr=RX1_Buffer[2];
 371   3               addr<<=8;
 372   3               addr+=RX1_Buffer[3]; 
 373   3               addr<<=1;
 374   3               if(RX1_Buffer[1]==3){
 375   4                 len=RX1_Buffer[rx1_cnt-3]*2;
 376   4                 RX1_Buffer[1]=3;
 377   4                 RX1_Buffer[2]=len;
 378   4                 for(i=3;i<len+3;i++){
 379   5                   RX1_Buffer[i]=Modbuf_Buffer[addr];
 380   5                   addr++;
 381   5                 }
 382   4                 P55=1;
 383   4                 crc_buf=usMBCRC16(len+3);
 384   4                 RX1_Buffer[len+4]=crc_buf/256;
 385   4                 RX1_Buffer[len+3]=crc_buf%256;
 386   4                 tx1_end=len+5;
 387   4                 tx1_cnt=1;
 388   4                 SBUF=ID;
 389   4               }
 390   3               else if(RX1_Buffer[1]==6){
 391   4                 Modbuf_Buffer[addr]=RX1_Buffer[4];
 392   4                 addr++;
 393   4                 Modbuf_Buffer[addr]=RX1_Buffer[5];
 394   4                 P55=1;
 395   4                 tx1_end=rx1_cnt;
 396   4                 tx1_cnt=1;
 397   4                 SBUF=ID; 
 398   4               }
 399   3               else if(RX1_Buffer[1]==16){
 400   4                 len=RX1_Buffer[6]+7;
 401   4                 for(i=7; i<len; i++){
 402   5                    Modbuf_Buffer[addr]=RX1_Buffer[i];
 403   5                    addr++;
 404   5                 }
 405   4                 crc_buf=usMBCRC16(6);
 406   4                 RX1_Buffer[7]=crc_buf/256;
 407   4                 RX1_Buffer[6]=crc_buf%256;
 408   4                 P55=1;
 409   4                 tx1_end=8;
 410   4                 tx1_cnt=1;
 411   4                 SBUF=ID; 
 412   4               }
 413   3             }
 414   2           }
 415   1      
 416   1      }
 417          /**********************************************/
 418          void output(void){
 419   1       
 420   1           if(Modbuf_Buffer[1]&1){
 421   2             P34=0;
 422   2           }
 423   1           else{
 424   2             P34=1;
 425   2           }
 426   1           if(Modbuf_Buffer[1]&2){
C51 COMPILER V9.52.0.0   MAIN                                                              08/12/2018 14:29:52 PAGE 8   

 427   2             P35=0;
 428   2           }
 429   1           else{
 430   2             P35=1;
 431   2           }   
 432   1      }
 433          /**********************************************/
 434          void GET_ADC(void){
 435   1           if(ch==4){
 436   2             adc1=ADC_RES;
 437   2           adc1<<=2;
 438   2           adc1+=ADC_RESL;
 439   2             Modbuf_Buffer[2]=adc1/256;
 440   2             Modbuf_Buffer[3]=adc1%256;
 441   2             ch=5;
 442   2           ADC_CONTR = ADC_POWER | ADC_SPEEDLL | ch | ADC_START;
 443   2           if(adc1>A_max1){
 444   3               A_max1=adc1;
 445   3             }
 446   2             else if(adc1<A_min1){
 447   3               A_min1=adc1;
 448   3             }
 449   2           }
 450   1           else if(ch==5){
 451   2             adc2=ADC_RES;
 452   2           adc2<<=2;
 453   2           adc2+=ADC_RESL;
 454   2             Modbuf_Buffer[4]=adc2/256;
 455   2             Modbuf_Buffer[5]=adc2%256;
 456   2             ch=2;
 457   2           ADC_CONTR = ADC_POWER | ADC_SPEEDLL | ch | ADC_START;
 458   2           if(adc2>A_max2){
 459   3               A_max2=adc2;
 460   3             }
 461   2             else if(adc2<A_min2){
 462   3               A_min2=adc2;
 463   3             }
 464   2           }   
 465   1           else if(ch==2){
 466   2             adc3=ADC_RES;
 467   2           adc3<<=2;
 468   2           adc3+=ADC_RESL;
 469   2             Modbuf_Buffer[6]=adc3/256;
 470   2             Modbuf_Buffer[7]=adc3%256;
 471   2             ch=3;
 472   2           ADC_CONTR = ADC_POWER | ADC_SPEEDLL | ch | ADC_START;
 473   2           if(adc3>V_max1){
 474   3               V_max1=adc3;    
 475   3             }
 476   2           count2++;
 477   2           }   
 478   1           else if(ch==3){
 479   2             adc4=ADC_RES;
 480   2           adc4<<=2;
 481   2           adc4+=ADC_RESL;
 482   2             Modbuf_Buffer[8]=adc4/256;
 483   2             Modbuf_Buffer[9]=adc4%256;
 484   2             ch=4;
 485   2           ADC_CONTR = ADC_POWER | ADC_SPEEDLL | ch | ADC_START;
 486   2           if(adc4>V_max2){
 487   3               V_max2=adc4;  
 488   3             }
C51 COMPILER V9.52.0.0   MAIN                                                              08/12/2018 14:29:52 PAGE 9   

 489   2           count2++;
 490   2           }
 491   1      }
 492          /**********************************************/
 493          void Cal_adc(void){
 494   1         if(A_max1>520){
 495   2             A_max1=((A_max1-520)*10)/22;
 496   2             Modbuf_Buffer[10]=A_max1/256;
 497   2             Modbuf_Buffer[11]=A_max1%256;             
 498   2           }
 499   1         
 500   1           if(A_min1<520){
 501   2             A_min1=((520-A_min1)*10)/22;
 502   2             Modbuf_Buffer[12]=A_min1/256;
 503   2             Modbuf_Buffer[13]=A_min1%256;             
 504   2           }
 505   1         
 506   1         if(A_max2>520){
 507   2             A_max2=((A_max2-520)*10)/22;
 508   2             Modbuf_Buffer[14]=A_max2/256;
 509   2             Modbuf_Buffer[15]=A_max2%256;             
 510   2           }
 511   1         
 512   1           if(A_min2<520){
 513   2             A_min2=((520-A_min2)*10)/22;
 514   2             Modbuf_Buffer[16]=A_min2/256;
 515   2             Modbuf_Buffer[17]=A_min2%256;             
 516   2           }
 517   1         if(V_max1<=340){
 518   2          V_max1=V_max1/3; 
 519   2         }
 520   1         else{
 521   2          V_max1=(V_max1*4)/17;
 522   2         }
 523   1           Modbuf_Buffer[18]=V_max1/256;
 524   1           Modbuf_Buffer[19]=V_max1%256;
 525   1      
 526   1         if(V_max2<=340){
 527   2          V_max2=V_max2/3; 
 528   2         }
 529   1         else{
 530   2          V_max2=(V_max2*4)/17;
 531   2         } 
 532   1         Modbuf_Buffer[20]=V_max2/256;
 533   1           Modbuf_Buffer[21]=V_max2%256;  
 534   1         
 535   1         A_min1=520;
 536   1           A_max1=0;
 537   1           V_max1=0;  
 538   1         A_min2=520;
 539   1           A_max2=0;
 540   1           V_max2=0;   
 541   1      }
 542          /**********************************************/
 543          void Cal_DHT11(void){
 544   1      unsigned char i,j;
 545   1           j=0;
 546   1           for(i=2;i<10;i++){
 547   2           j<<=1;
 548   2          if(DHT11_buf[i]>3){
 549   3            j|=1;
 550   3          } 
C51 COMPILER V9.52.0.0   MAIN                                                              08/12/2018 14:29:52 PAGE 10  

 551   2         }   
 552   1         Modbuf_Buffer[22]=j;
 553   1         j=0;
 554   1           for(i=10;i<18;i++){
 555   2           j<<=1;
 556   2          if(DHT11_buf[i]>3){
 557   3            j|=1;
 558   3          } 
 559   2         }   
 560   1         Modbuf_Buffer[23]=j;
 561   1           for(i=18;i<26;i++){
 562   2           j<<=1;
 563   2          if(DHT11_buf[i]>3){
 564   3            j|=1;
 565   3          } 
 566   2         }   
 567   1         Modbuf_Buffer[24]=j;
 568   1         j=0;
 569   1           for(i=26;i<34;i++){
 570   2           j<<=1;
 571   2          if(DHT11_buf[i]>3){
 572   3            j|=1;
 573   3          } 
 574   2         }   
 575   1         Modbuf_Buffer[25]=j;  
 576   1      }
 577          /**********************************************/
 578          /*----------------------------
 579          ?件延?
 580          ----------------------------*/
 581          void Delay(BYTE n)
 582          {
 583   1          WORD x;
 584   1      
 585   1          while (n--)
 586   1          {
 587   2              x = 0;
 588   2              while (++x);
 589   2          }
 590   1      }
 591          
 592          /*----------------------------
 593          ??IAP
 594          ----------------------------*/
 595          void IapIdle()
 596          {
 597   1          IAP_CONTR = 0;                  //??IAP功能
 598   1          IAP_CMD = 0;                    //清除指令寄存器
 599   1          IAP_TRIG = 0;                   //清除|?寄存器
 600   1          IAP_ADDRH = 0x80;               //?位址?置到非IAP?W域
 601   1          IAP_ADDRL = 0;
 602   1      }
 603          
 604          /*----------------------------
 605          ?ISP/IAP/EEPROM?W域?取一字?
 606          ----------------------------*/
 607          BYTE IapReadByte(WORD addr)
 608          {
 609   1          BYTE dat;                       //????
 610   1      
 611   1          IAP_CONTR = ENABLE_IAP;         //使能IAP
 612   1          IAP_CMD = CMD_READ;             //?置IAP指令
C51 COMPILER V9.52.0.0   MAIN                                                              08/12/2018 14:29:52 PAGE 11  

 613   1          IAP_ADDRL = addr;               //?置IAP低位址
 614   1          IAP_ADDRH = addr >> 8;          //?置IAP高位址
 615   1          IAP_TRIG = 0x5a;                //?|?指令(0x5a)
 616   1          IAP_TRIG = 0xa5;                //?|?指令(0xa5)
 617   1          _nop_();                        //等待ISP/IAP/EEPROM作I完成
 618   1          dat = IAP_DATA;                 //?ISP/IAP/EEPROM?
 619   1          IapIdle();                      //??IAP功能
 620   1      
 621   1          return dat;                     //返回
 622   1      }
 623          
 624          /*----------------------------
 625          ?一字??到ISP/IAP/EEPROM?W域
 626          ----------------------------*/
 627          void IapProgramByte(WORD addr, BYTE dat)
 628          {
 629   1          IAP_CONTR = ENABLE_IAP;         //使能IAP
 630   1          IAP_CMD = CMD_PROGRAM;          //?置IAP指令
 631   1          IAP_ADDRL = addr;               //?置IAP低位址
 632   1          IAP_ADDRH = addr >> 8;          //?置IAP高位址
 633   1          IAP_DATA = dat;                 //?ISP/IAP/EEPROM?
 634   1          IAP_TRIG = 0x5a;                //?|?指令(0x5a)
 635   1          IAP_TRIG = 0xa5;                //?|?指令(0xa5)
 636   1          _nop_();                        //等待ISP/IAP/EEPROM作I完成
 637   1          IapIdle();
 638   1      }
 639          
 640          /*----------------------------
 641          扇?擦除
 642          ----------------------------*/
 643          void IapEraseSector(WORD addr)
 644          {
 645   1          IAP_CONTR = ENABLE_IAP;         //使能IAP
 646   1          IAP_CMD = CMD_ERASE;            //?置IAP指令
 647   1          IAP_ADDRL = addr;               //?置IAP低位址
 648   1          IAP_ADDRH = addr >> 8;          //?置IAP高位址
 649   1          IAP_TRIG = 0x5a;                //?|?指令(0x5a)
 650   1          IAP_TRIG = 0xa5;                //?|?指令(0xa5)
 651   1          _nop_();                        //等待ISP/IAP/EEPROM作I完成
 652   1          IapIdle();
 653   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3296    ----
   CONSTANT SIZE    =    512    ----
   XDATA SIZE       =   2657       8
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
